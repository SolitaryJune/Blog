---
layout:     post
title:      "STM32启动流程分析"
subtitle:   "嵌入式，FreeRTOS，STM32"
date:       2017-03-20
author:     "elmagnifico"
header-img: "img/Embedded-head-bg.png"
catalog:    true
tags:
    - 嵌入式
    - FreeRTOS
---

## STM32启动文件分析


#### 环境

编译环境：keil 5.23

固件库：Keil.STM32F7xx_DFP.2.9.0

开发板：STM32F767

#### STM32F767启动流程

以前的Cortex M3内核，有三种启动方式：

- 通过boot引脚设置可以将中断向量表定位于SRAM区，即起始地址为0x2000000，同时复位后PC指针位于0x2000000处
- 通过boot引脚设置可以将中断向量表定位于FLASH区，即起始地址为0x8000000，同时复位后PC指针位于0x8000000处
- 通过boot引脚设置可以将中断向量表定位于内置Bootloader区，

Cortex-M3内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在Cortex-M3内核复位后，会自动从起始地址的下一个32位空间取出复位中断入口向量，跳转执行复位中断服务程序。Cortex-M3内核是固定了中断向量表的位置而起始地址是可变化的.

M4和M3基本一样，但是到了M7的时候，这里就不同了。

从哪里启动，不再是光boot引脚就能决定的了，需要参考对应的BOOT_ADD0和BOOT_ADD1来决定

在 STM32F7 系列的芯片上，图中的 BOOT0 和 BOOT1 只有 BOOT0 有效，对应 STM32F7
芯片的 B00T 引脚。STM32F7 的启动模式（也称自举模式），如表 2.1.8.1 所示：
启动模式选择
启动地址


|BOOT0|启动地址选项字节|启动地址|
|--|--|
|0|BOOT_ADD0[15:0]|由用户选项字节BOOT_ADD0[15:0]决定启动地址,ST 出厂默认的启动地址为:0X0020 0000 的 ITCM 上的 Flash|
|1|BOOT_ADD1[15:0]|由用户选项字节BOOT_ADD1[15:0]决定启动地址,ST 出厂默认的启动地址为:0X0010 0000 的 ITCM 上的 Flash|

- BOOT_ADDx = 0x0000：从 ITCM RAM(0x0000 0000)启动
- BOOT_ADDx = 0x0040：从系统存储器(0x0010 0000)启动
- BOOT_ADDx = 0x0080：从 ITCM 接口上的 FLASH (0x0020 0000)启动
- BOOT_ADDx = 0x2000：从 AXIM 接口上的 FLASH (0x0800 0000)启动
- BOOT_ADDx = 0x8000：从 DTCM RAM(0x2000 0000)启动
- BOOT_ADDx = 0x8004：从 SRAM1(0x2001 0000)启动
- BOOT_ADDx = 0x8013：从 SRAM2(0x2004 C000)启动
- x=0/1，出厂时：BOOT_ADD0=0X0080；BOOT_ADD1=0X0040

首先对栈和堆的大小进行定义，并在代码区的起始处建立中断向量表，其第一个表项是栈顶地址，第二个表项是复位中断服务入口地址。然后在复位中断服务程序中跳转¬¬C/C++标准实时库的__main函数，完成用户堆栈等的初始化后，跳转.c文件中的main函数开始执行C程序。假设STM32被设置为从内部FLASH启动（这也是最常见的一种情况），中断向量表起始地位为0x8000000，则栈顶地址存放于0x8000000处，而复位中断服务入口地址存放于0x8000004处。当STM32遇到复位信号后，则从0x80000004处取出复位中断服务入口地址，继而执行复位中断服务程序，然后跳转__main函数，最后进入mian函数，来到C的世界！！

STM整个启动过程是指从上电开始，一直到运行到main函数之间的这段过程，步骤为（以使用微库为例）：

①上电后硬件设置SP、PC

②设置系统时钟

③软件设置SP

④加载.data、.bss，并初始化栈区

⑤跳转到C文件的main函数


新一代Cortex内核架构的启动方式有了比较大的变化。ARM7/ARM9内核的控制器在复位后，CPU会从存储空间的绝对地址0x000000取出第一条指令执行复位中断服务程序的方式启动，即固定了复位后的起始地址为0x000000（PC = 0x000000）同时中断向量表的位置并不是固定的。而Cortex-M3内核则正好相反，有3种情况:
  1、通过boot引脚设置可以将中断向量表定位于SRAM区，即起始地址为0x2000000，同时复位后PC指针位于0x2000000处；
  2、通过boot引脚设置可以将中断向量表定位于FLASH区，即起始地址为0x8000000，同时复位后PC指针位于0x8000000处；
  3、通过boot引脚设置可以将中断向量表定位于内置Bootloader区，本文不对这种情况做论述；
而Cortex-M3内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在Cortex-M3内核复位后，会自动从起始地址的下一个32位空间取出复位中断入口向量，跳转执行复位中断服务程序。对比ARM7/ARM9内核，Cortex-M3内核则是固定了中断向量表的位置而起始地址是可变化的。
有了上述准备只是后，下面以STM32的2.02固件库提供的启动文件“stm32f10x_vector.s”为模板，对STM32的启动过程做一个简要而全面的解析。

startup_stm32f10x_XX.s  这个文件里面首先定义了复位中断（复位入口矢量被硬件固定在地址 0x0000_0004）的处理函数：Reset_Handler，它的作用就是将保存于flash中的初始化数据复制到sram中，调用上面说到的SystemInit来初始化时钟，接着跳转到main执行。  接着定义了Default_Handler， 这个是作为其他所有中断的默认处理函数，作用就是死循环，所以你假如开启了某个中断，请按照这里面的中断函数名给它写中断处理函数，例如串口中断处理函数名是USART1_IRQHandler，你开了串口中断，如果不重写USART1_IRQHandler，就默认执行Default_Handler，死循环了。而如果你有重写，那么中断向量表中的处理函数的地址就会更新为你自己写的那个函数的地址了。为什么会这样呢?因为此文件的末尾用了类似这样的语句：      .weak    USART1_IRQHandler      .thumb_set USART1_IRQHandler,Default_Handler  它给中断处理函数提供了弱（weak）别名（Default_Handler），如果不重写，中断了默认执行Default_Handler，如果重写了，因为是弱别名，所以会被你写的同名函数覆盖。  在中断向量表中第一个存放的是复位中断向量，STM32MDK环境中

















## 总结

到这里启动文件分析就结束了，但是如果只看了这里其实还是没看明白怎么回事，还需要对STM32的启动过程有一个了解，才能明白这里做了什么事。

## Quote

> 
